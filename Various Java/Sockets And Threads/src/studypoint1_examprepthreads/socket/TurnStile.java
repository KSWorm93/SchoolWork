package studypoint1_examprepthreads.socket;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.util.HashMap;import java.util.Map;import java.util.logging.Level;import java.util.logging.Logger;public class TurnStile {            public static void main(String[] args) throws IOException {                Even even = new Even();        String ip = "localhost";        int port = 1331;        int id = 0;        HashMap<Integer, TurnStile> stiles = new HashMap();                if (args.length == 2) {            System.out.println("Args found -> Setting IP and PORT");            ip = args[0];            port = Integer.parseInt(args[1]);        }        for (Map.Entry<Integer, TurnStile> entrySet : stiles.entrySet()) {            Integer key = entrySet.getKey();            TurnStile value = entrySet.getValue();            if (key == id) {                id++;            }        }        ServerSocket ss = new ServerSocket();        ss.bind(new InetSocketAddress(ip, port));                while (true) {            TurnStileThread ts = new TurnStileThread(ss.accept(), id, even);            Thread t1 = new Thread(ts);            t1.start();            id++;        }    }        public static class TurnStileThread implements Runnable {        Socket s;        BufferedReader in;        PrintWriter out;        Even even;        int turnStile_Id;        long tsNumber = 0;         HashMap<Integer, TurnStile> stiles;                public TurnStileThread(Socket socket, int id, Even even) {            s = socket;            turnStile_Id = id;            this.even = even;        }        @Override        public void run() {            try {                in = new BufferedReader(new InputStreamReader(s.getInputStream()));                out = new PrintWriter(s.getOutputStream(), true);                out.println("TURNSTILE-" + turnStile_Id);                while (true) {                    String temp = in.readLine().toLowerCase();                    switch (temp) {                        case "pass":                            tsNumber++;                            even.setVisitorsNumber();                                                        out.println("Number from this turnStile: " + tsNumber);                            break;                        case "total":                            out.println("Total visitors: " + even.getVisitorsNumber());                            break;                        default:                            out.println("Command not found");                                                                        }                    if (in.readLine().equalsIgnoreCase("pass")) {                        tsNumber++;                        even.setVisitorsNumber();                    }                                    }            } catch (IOException ex) {                Logger.getLogger(TurnStile.class.getName()).log(Level.SEVERE, null, ex);            }        }    }    public static class Even {        long visitorsNumber = 0;        public synchronized long getVisitorsNumber() {            return visitorsNumber;        }        public synchronized void setVisitorsNumber() {            visitorsNumber++;        }    }}/*When and why we will use Threads in our programs?    Når vi vil udnytte den fulde kraft en cpu har, med alle dens kerner istedet for kun at køre med 1 kerne.    Threads gør at flere opgaver kan arbejde samtidig.Explain about the Race Condition Problem and ways to solve it in Java    Race Condition er når 2eller flere tråde bliver sat igang næsten samtidig og de begge skal ændre på samme variabel.    Måder man kan løse problemet på:     -Bruge synchronized, som gør at kun én tråd kan have fat i variablen af gangen    -Lock() som låser et stykke kode, når en tråd kommer ind, låser den koden så kun DEN kan have fat i det stykke kode     indtil den er færdig eller Unlocker for koden.Explain how we can write reusable non-blocking Java Controls using Threads    Explain about deadlocks, how to detect them and ways to solve the Deadlock Problem    Deadlocks kan fx ske hvis 2 tråde skal bruge 2forskellige elementer, og den 1 tråd låser det 1 element    og den 2 tråd låser det 2 element, men ingen af dem kommer videre uden den anden element, men vil ikke give sig    så programmet står stille.    måder man kan undgå/løse deadlocks:    -én måde at gøre det på, er at have en method som leder efter steder i programmet hvor der er opstået deadlock     hvorefter den så sætter alle threads til at restarte, og så håber man på det ikke sker igen.    -en mere optimal måde at gøre er ved at restarte 1enkelt thread og se om de andre løser sig selv*/